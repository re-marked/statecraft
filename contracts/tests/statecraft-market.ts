/**
 * statecraft-market — Integration Tests
 *
 * Run with:
 *   anchor test           (starts a local validator automatically)
 *   anchor test --skip-local-validator  (uses existing running validator)
 *
 * These tests exercise every instruction in order:
 *   create_pool → place_bet (multiple bettors) → close_betting
 *               → settle → claim (winners) + reject (losers)
 */

import * as anchor from "@coral-xyz/anchor";
import { Program, BN } from "@coral-xyz/anchor";
import { PublicKey, Keypair, LAMPORTS_PER_SOL, SystemProgram } from "@solana/web3.js";
import { assert } from "chai";

// The IDL is generated by `anchor build` into target/idl/statecraft_market.json
// Import the type from the generated file once built.
// import { StatecraftMarket } from "../target/types/statecraft_market";

// ─── Helpers ─────────────────────────────────────────────────────────────────

function makeGameId(str: string): number[] {
  const buf = Buffer.alloc(32);
  Buffer.from(str).copy(buf);
  return Array.from(buf);
}

async function airdrop(
  connection: anchor.web3.Connection,
  pubkey: PublicKey,
  sol: number = 10
) {
  const sig = await connection.requestAirdrop(
    pubkey,
    sol * LAMPORTS_PER_SOL
  );
  await connection.confirmTransaction(sig, "confirmed");
}

function poolPda(
  gameId: number[],
  programId: PublicKey
): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("pool"), Buffer.from(gameId)],
    programId
  );
}

function betPda(
  poolKey: PublicKey,
  bettorKey: PublicKey,
  programId: PublicKey
): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("bet"), poolKey.toBuffer(), bettorKey.toBuffer()],
    programId
  );
}

// ─── Test Suite ───────────────────────────────────────────────────────────────

describe("statecraft-market", () => {
  // Use the Anchor provider configured in Anchor.toml
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  // Load the compiled program. Cast to `any` until IDL is generated.
  const program = anchor.workspace.StatecraftMarket as Program<any>;
  const connection = provider.connection;

  // ── Actors ──────────────────────────────────────────────────────────────────
  const owner = Keypair.generate();   // Pool authority (settles the game)
  const alice = Keypair.generate();   // Bets on slot 0 (France)
  const bob = Keypair.generate();     // Bets on slot 0 (France)
  const charlie = Keypair.generate(); // Bets on slot 1 (Germany — loses)

  // ── Game / Pool config ──────────────────────────────────────────────────────
  const GAME_ID = makeGameId("test-game-2026-01");
  const N_SLOTS = 3; // France=0, Germany=1, UK=2
  const WINNING_SLOT = 0; // France wins

  let poolKey: PublicKey;
  let poolBump: number;

  // ── Airdrop SOL to all actors before tests ──────────────────────────────────
  before(async () => {
    await Promise.all([
      airdrop(connection, owner.publicKey, 5),
      airdrop(connection, alice.publicKey, 10),
      airdrop(connection, bob.publicKey, 10),
      airdrop(connection, charlie.publicKey, 10),
    ]);

    [poolKey, poolBump] = poolPda(GAME_ID, program.programId);
    console.log("Pool PDA:", poolKey.toBase58());
  });

  // ─────────────────────────────────────────────────────────────────────────
  // 1. create_pool
  // ─────────────────────────────────────────────────────────────────────────

  it("creates a pool", async () => {
    const tx = await program.methods
      .createPool(GAME_ID, N_SLOTS)
      .accounts({
        pool: poolKey,
        owner: owner.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([owner])
      .rpc();

    console.log("create_pool tx:", tx);

    const pool = await program.account.gamePool.fetch(poolKey);
    assert.equal(pool.nSlots, N_SLOTS);
    assert.equal(pool.winningSlot, -1);
    assert.equal(pool.totalLamports.toNumber(), 0);
    assert.isTrue(pool.isOpen);
    assert.isFalse(pool.isSettled);
    assert.equal(pool.owner.toBase58(), owner.publicKey.toBase58());
  });

  it("rejects duplicate pool creation", async () => {
    try {
      await program.methods
        .createPool(GAME_ID, N_SLOTS)
        .accounts({
          pool: poolKey,
          owner: owner.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([owner])
        .rpc();
      assert.fail("Should have thrown");
    } catch (e: any) {
      // Anchor throws when trying to re-init an existing PDA
      assert.ok(e.message, "expected error on duplicate create");
    }
  });

  // ─────────────────────────────────────────────────────────────────────────
  // 2. place_bet
  // ─────────────────────────────────────────────────────────────────────────

  it("alice bets 2 SOL on France (slot 0)", async () => {
    const betAmount = 2 * LAMPORTS_PER_SOL;
    const [betKey] = betPda(poolKey, alice.publicKey, program.programId);

    await program.methods
      .placeBet(0, new BN(betAmount))
      .accounts({
        pool: poolKey,
        bet: betKey,
        bettor: alice.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([alice])
      .rpc();

    const bet = await program.account.bet.fetch(betKey);
    assert.equal(bet.slot, 0);
    assert.equal(bet.lamports.toNumber(), betAmount);
    assert.isFalse(bet.claimed);

    const pool = await program.account.gamePool.fetch(poolKey);
    assert.equal(pool.totalLamports.toNumber(), betAmount);
    assert.equal(pool.slotTotals[0].toNumber(), betAmount);
  });

  it("alice adds another 1 SOL to her France bet (init_if_needed)", async () => {
    const addAmount = 1 * LAMPORTS_PER_SOL;
    const [betKey] = betPda(poolKey, alice.publicKey, program.programId);

    await program.methods
      .placeBet(0, new BN(addAmount))
      .accounts({
        pool: poolKey,
        bet: betKey,
        bettor: alice.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([alice])
      .rpc();

    const bet = await program.account.bet.fetch(betKey);
    assert.equal(bet.lamports.toNumber(), 3 * LAMPORTS_PER_SOL); // 2+1

    const pool = await program.account.gamePool.fetch(poolKey);
    assert.equal(pool.totalLamports.toNumber(), 3 * LAMPORTS_PER_SOL);
  });

  it("bob bets 2 SOL on France (slot 0)", async () => {
    const betAmount = 2 * LAMPORTS_PER_SOL;
    const [betKey] = betPda(poolKey, bob.publicKey, program.programId);

    await program.methods
      .placeBet(0, new BN(betAmount))
      .accounts({
        pool: poolKey,
        bet: betKey,
        bettor: bob.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([bob])
      .rpc();

    const pool = await program.account.gamePool.fetch(poolKey);
    assert.equal(pool.totalLamports.toNumber(), 5 * LAMPORTS_PER_SOL);
    assert.equal(pool.slotTotals[0].toNumber(), 5 * LAMPORTS_PER_SOL);
  });

  it("charlie bets 5 SOL on Germany (slot 1)", async () => {
    const betAmount = 5 * LAMPORTS_PER_SOL;
    const [betKey] = betPda(poolKey, charlie.publicKey, program.programId);

    await program.methods
      .placeBet(1, new BN(betAmount))
      .accounts({
        pool: poolKey,
        bet: betKey,
        bettor: charlie.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([charlie])
      .rpc();

    const pool = await program.account.gamePool.fetch(poolKey);
    // Total: alice 3 + bob 2 + charlie 5 = 10 SOL
    assert.equal(pool.totalLamports.toNumber(), 10 * LAMPORTS_PER_SOL);
    assert.equal(pool.slotTotals[1].toNumber(), 5 * LAMPORTS_PER_SOL);
  });

  it("rejects invalid slot (slot >= n_slots)", async () => {
    const [betKey] = betPda(poolKey, alice.publicKey, program.programId);
    try {
      await program.methods
        .placeBet(N_SLOTS, new BN(LAMPORTS_PER_SOL)) // slot == n_slots (out of range)
        .accounts({
          pool: poolKey,
          bet: betKey,
          bettor: alice.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();
      assert.fail("Should have thrown InvalidSlot");
    } catch (e: any) {
      assert.include(e.message, "InvalidSlot");
    }
  });

  // ─────────────────────────────────────────────────────────────────────────
  // 3. close_betting
  // ─────────────────────────────────────────────────────────────────────────

  it("owner closes betting", async () => {
    await program.methods
      .closeBetting()
      .accounts({
        pool: poolKey,
        owner: owner.publicKey,
      })
      .signers([owner])
      .rpc();

    const pool = await program.account.gamePool.fetch(poolKey);
    assert.isFalse(pool.isOpen);
    assert.isFalse(pool.isSettled); // still unsettled
  });

  it("rejects bet after betting is closed", async () => {
    const [betKey] = betPda(poolKey, alice.publicKey, program.programId);
    try {
      await program.methods
        .placeBet(0, new BN(LAMPORTS_PER_SOL))
        .accounts({
          pool: poolKey,
          bet: betKey,
          bettor: alice.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();
      assert.fail("Should have thrown BettingClosed");
    } catch (e: any) {
      assert.include(e.message, "BettingClosed");
    }
  });

  it("rejects close_betting from non-owner", async () => {
    // Re-open would be needed but we just test the auth check with alice as signer
    try {
      await program.methods
        .closeBetting()
        .accounts({
          pool: poolKey,
          owner: alice.publicKey, // wrong signer
        })
        .signers([alice])
        .rpc();
      assert.fail("Should have thrown Unauthorized");
    } catch (e: any) {
      assert.ok(e.message, "expected auth error");
    }
  });

  // ─────────────────────────────────────────────────────────────────────────
  // 4. settle
  // ─────────────────────────────────────────────────────────────────────────

  it("owner settles the pool — France (slot 0) wins", async () => {
    await program.methods
      .settle(WINNING_SLOT)
      .accounts({
        pool: poolKey,
        owner: owner.publicKey,
      })
      .signers([owner])
      .rpc();

    const pool = await program.account.gamePool.fetch(poolKey);
    assert.isTrue(pool.isSettled);
    assert.isFalse(pool.isOpen);
    assert.equal(pool.winningSlot, WINNING_SLOT);
  });

  it("rejects double-settle", async () => {
    try {
      await program.methods
        .settle(WINNING_SLOT)
        .accounts({
          pool: poolKey,
          owner: owner.publicKey,
        })
        .signers([owner])
        .rpc();
      assert.fail("Should have thrown AlreadySettled");
    } catch (e: any) {
      assert.include(e.message, "AlreadySettled");
    }
  });

  // ─────────────────────────────────────────────────────────────────────────
  // 5. claim
  // ─────────────────────────────────────────────────────────────────────────
  //
  // Pool: 10 SOL total. France (slot 0) wins with 5 SOL staked.
  //   alice staked 3 SOL → payout = 3 * 10 / 5 = 6 SOL
  //   bob   staked 2 SOL → payout = 2 * 10 / 5 = 4 SOL
  //   charlie (Germany)  → InvalidSlot, gets nothing

  it("alice claims her winnings (6 SOL)", async () => {
    const [betKey] = betPda(poolKey, alice.publicKey, program.programId);

    const balanceBefore = await connection.getBalance(alice.publicKey);

    await program.methods
      .claim()
      .accounts({
        pool: poolKey,
        bet: betKey,
        bettor: alice.publicKey,
      })
      .signers([alice])
      .rpc();

    const balanceAfter = await connection.getBalance(alice.publicKey);
    const received = balanceAfter - balanceBefore;

    // Expected payout = 6 SOL; allow ±0.01 SOL for tx fees
    const expectedPayout = 6 * LAMPORTS_PER_SOL;
    assert.approximately(received, expectedPayout, 0.01 * LAMPORTS_PER_SOL,
      `alice should receive ~6 SOL, got ${received / LAMPORTS_PER_SOL}`);

    const bet = await program.account.bet.fetch(betKey);
    assert.isTrue(bet.claimed);
  });

  it("alice cannot claim again", async () => {
    const [betKey] = betPda(poolKey, alice.publicKey, program.programId);
    try {
      await program.methods
        .claim()
        .accounts({
          pool: poolKey,
          bet: betKey,
          bettor: alice.publicKey,
        })
        .signers([alice])
        .rpc();
      assert.fail("Should have thrown AlreadyClaimed");
    } catch (e: any) {
      assert.include(e.message, "AlreadyClaimed");
    }
  });

  it("bob claims his winnings (4 SOL)", async () => {
    const [betKey] = betPda(poolKey, bob.publicKey, program.programId);
    const balanceBefore = await connection.getBalance(bob.publicKey);

    await program.methods
      .claim()
      .accounts({
        pool: poolKey,
        bet: betKey,
        bettor: bob.publicKey,
      })
      .signers([bob])
      .rpc();

    const balanceAfter = await connection.getBalance(bob.publicKey);
    const received = balanceAfter - balanceBefore;
    const expectedPayout = 4 * LAMPORTS_PER_SOL;
    assert.approximately(received, expectedPayout, 0.01 * LAMPORTS_PER_SOL,
      `bob should receive ~4 SOL, got ${received / LAMPORTS_PER_SOL}`);
  });

  it("charlie (losing bettor) cannot claim", async () => {
    const [betKey] = betPda(poolKey, charlie.publicKey, program.programId);
    try {
      await program.methods
        .claim()
        .accounts({
          pool: poolKey,
          bet: betKey,
          bettor: charlie.publicKey,
        })
        .signers([charlie])
        .rpc();
      assert.fail("Should have thrown InvalidSlot");
    } catch (e: any) {
      assert.include(e.message, "InvalidSlot");
    }
  });

  it("cannot claim before settlement", async () => {
    // This test uses a fresh pool to verify NotSettled error path.
    const gameId2 = makeGameId("test-game-unsettled");
    const [poolKey2] = poolPda(gameId2, program.programId);

    // Create second pool
    await program.methods
      .createPool(gameId2, 3)
      .accounts({
        pool: poolKey2,
        owner: owner.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([owner])
      .rpc();

    // Alice bets
    const [betKey2] = betPda(poolKey2, alice.publicKey, program.programId);
    await program.methods
      .placeBet(0, new BN(LAMPORTS_PER_SOL))
      .accounts({
        pool: poolKey2,
        bet: betKey2,
        bettor: alice.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([alice])
      .rpc();

    // Try to claim without settling
    try {
      await program.methods
        .claim()
        .accounts({
          pool: poolKey2,
          bet: betKey2,
          bettor: alice.publicKey,
        })
        .signers([alice])
        .rpc();
      assert.fail("Should have thrown NotSettled");
    } catch (e: any) {
      assert.include(e.message, "NotSettled");
    }
  });

  // ─────────────────────────────────────────────────────────────────────────
  // Summary
  // ─────────────────────────────────────────────────────────────────────────

  after(async () => {
    const pool = await program.account.gamePool.fetch(poolKey);
    console.log("\n=== Pool final state ===");
    console.log("  total_lamports:", pool.totalLamports.toNumber() / LAMPORTS_PER_SOL, "SOL");
    console.log("  winning_slot  :", pool.winningSlot);
    console.log("  is_settled    :", pool.isSettled);
    console.log("  slot_totals   :", pool.slotTotals.map((s: BN) => s.toNumber() / LAMPORTS_PER_SOL));
  });
});
